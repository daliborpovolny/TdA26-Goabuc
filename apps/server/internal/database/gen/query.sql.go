// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package database

import (
	"context"
	"database/sql"
)

const assignHeadingToModule = `-- name: AssignHeadingToModule :one


INSERT INTO heading_to_module (
    module_uuid, heading_uuid, order
) VALUES (
    ?, ?, ?
) RETURNING module_uuid, heading_uuid, "order"
`

type AssignHeadingToModuleParams struct {
	ModuleUuid  string `json:"module_uuid"`
	HeadingUuid string `json:"heading_uuid"`
	Order       int64  `json:"order"`
}

// * Module to Others Pairings
// HeadingToModule:
func (q *Queries) AssignHeadingToModule(ctx context.Context, arg AssignHeadingToModuleParams) (HeadingToModule, error) {
	row := q.db.QueryRowContext(ctx, assignHeadingToModule, arg.ModuleUuid, arg.HeadingUuid, arg.Order)
	var i HeadingToModule
	err := row.Scan(&i.ModuleUuid, &i.HeadingUuid, &i.Order)
	return i, err
}

const assignMaterialToModule = `-- name: AssignMaterialToModule :one

INSERT INTO material_to_module (
    module_uuid, material_uuid, order
) VALUES (
    ?, ?, ?
) RETURNING module_uuid, material_uuid, "order"
`

type AssignMaterialToModuleParams struct {
	ModuleUuid   string `json:"module_uuid"`
	MaterialUuid string `json:"material_uuid"`
	Order        int64  `json:"order"`
}

// MaterialToModule
func (q *Queries) AssignMaterialToModule(ctx context.Context, arg AssignMaterialToModuleParams) (MaterialToModule, error) {
	row := q.db.QueryRowContext(ctx, assignMaterialToModule, arg.ModuleUuid, arg.MaterialUuid, arg.Order)
	var i MaterialToModule
	err := row.Scan(&i.ModuleUuid, &i.MaterialUuid, &i.Order)
	return i, err
}

const assignQuizToModule = `-- name: AssignQuizToModule :one

INSERT INTO quiz_to_module (
    module_uuid, quiz_uuid, order
) VALUES (
    ?, ?, ?
) RETURNING module_uuid, quiz_uuid, "order"
`

type AssignQuizToModuleParams struct {
	ModuleUuid string `json:"module_uuid"`
	QuizUuid   string `json:"quiz_uuid"`
	Order      int64  `json:"order"`
}

// QuizToModule
func (q *Queries) AssignQuizToModule(ctx context.Context, arg AssignQuizToModuleParams) (QuizToModule, error) {
	row := q.db.QueryRowContext(ctx, assignQuizToModule, arg.ModuleUuid, arg.QuizUuid, arg.Order)
	var i QuizToModule
	err := row.Scan(&i.ModuleUuid, &i.QuizUuid, &i.Order)
	return i, err
}

const changeCourseState = `-- name: ChangeCourseState :one
UPDATE course
SET
    state = ?,
    updated_at = ?
WHERE uuid = ? RETURNING uuid, name, description, created_at, updated_at, archived, state
`

type ChangeCourseStateParams struct {
	State     interface{} `json:"state"`
	UpdatedAt int64       `json:"updated_at"`
	Uuid      string      `json:"uuid"`
}

func (q *Queries) ChangeCourseState(ctx context.Context, arg ChangeCourseStateParams) (Course, error) {
	row := q.db.QueryRowContext(ctx, changeCourseState, arg.State, arg.UpdatedAt, arg.Uuid)
	var i Course
	err := row.Scan(
		&i.Uuid,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Archived,
		&i.State,
	)
	return i, err
}

const changeHeadingInModuleOrder = `-- name: ChangeHeadingInModuleOrder :one
UPDATE heading_to_module
SET order = ?
WHERE heading_uuid = ? AND module_uuid = ?
RETURNING module_uuid, heading_uuid, "order"
`

type ChangeHeadingInModuleOrderParams struct {
	Order       int64  `json:"order"`
	HeadingUuid string `json:"heading_uuid"`
	ModuleUuid  string `json:"module_uuid"`
}

func (q *Queries) ChangeHeadingInModuleOrder(ctx context.Context, arg ChangeHeadingInModuleOrderParams) (HeadingToModule, error) {
	row := q.db.QueryRowContext(ctx, changeHeadingInModuleOrder, arg.Order, arg.HeadingUuid, arg.ModuleUuid)
	var i HeadingToModule
	err := row.Scan(&i.ModuleUuid, &i.HeadingUuid, &i.Order)
	return i, err
}

const changeMaterialInModuleOrder = `-- name: ChangeMaterialInModuleOrder :one
UPDATE material_to_module
SET order = ?
WHERE material_uuid = ? AND module_uuid = ?
RETURNING module_uuid, material_uuid, "order"
`

type ChangeMaterialInModuleOrderParams struct {
	Order        int64  `json:"order"`
	MaterialUuid string `json:"material_uuid"`
	ModuleUuid   string `json:"module_uuid"`
}

func (q *Queries) ChangeMaterialInModuleOrder(ctx context.Context, arg ChangeMaterialInModuleOrderParams) (MaterialToModule, error) {
	row := q.db.QueryRowContext(ctx, changeMaterialInModuleOrder, arg.Order, arg.MaterialUuid, arg.ModuleUuid)
	var i MaterialToModule
	err := row.Scan(&i.ModuleUuid, &i.MaterialUuid, &i.Order)
	return i, err
}

const changeModuleState = `-- name: ChangeModuleState :one
UPDATE module
SET
    state = ?,
    updated_at = ?
WHERE uuid = ? RETURNING uuid, course_uuid, name, description, state, created_at, updated_at
`

type ChangeModuleStateParams struct {
	State     interface{} `json:"state"`
	UpdatedAt int64       `json:"updated_at"`
	Uuid      string      `json:"uuid"`
}

func (q *Queries) ChangeModuleState(ctx context.Context, arg ChangeModuleStateParams) (Module, error) {
	row := q.db.QueryRowContext(ctx, changeModuleState, arg.State, arg.UpdatedAt, arg.Uuid)
	var i Module
	err := row.Scan(
		&i.Uuid,
		&i.CourseUuid,
		&i.Name,
		&i.Description,
		&i.State,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const changeQuizInModuleOrder = `-- name: ChangeQuizInModuleOrder :one
UPDATE quiz_to_module
SET order = ?
WHERE quiz_uuid = ? AND module_uuid = ?
RETURNING module_uuid, quiz_uuid, "order"
`

type ChangeQuizInModuleOrderParams struct {
	Order      int64  `json:"order"`
	QuizUuid   string `json:"quiz_uuid"`
	ModuleUuid string `json:"module_uuid"`
}

func (q *Queries) ChangeQuizInModuleOrder(ctx context.Context, arg ChangeQuizInModuleOrderParams) (QuizToModule, error) {
	row := q.db.QueryRowContext(ctx, changeQuizInModuleOrder, arg.Order, arg.QuizUuid, arg.ModuleUuid)
	var i QuizToModule
	err := row.Scan(&i.ModuleUuid, &i.QuizUuid, &i.Order)
	return i, err
}

const checkCourseExists = `-- name: CheckCourseExists :one
SELECT EXISTS (SELECT 1 FROM course WHERE uuid = ?) AS course_exists
`

func (q *Queries) CheckCourseExists(ctx context.Context, uuid string) (int64, error) {
	row := q.db.QueryRowContext(ctx, checkCourseExists, uuid)
	var course_exists int64
	err := row.Scan(&course_exists)
	return course_exists, err
}

const checkModuleExists = `-- name: CheckModuleExists :one
SELECT EXISTS (SELECT 1 FROM module WHERE uuid = ?) AS module_exists
`

func (q *Queries) CheckModuleExists(ctx context.Context, uuid string) (int64, error) {
	row := q.db.QueryRowContext(ctx, checkModuleExists, uuid)
	var module_exists int64
	err := row.Scan(&module_exists)
	return module_exists, err
}

const createCourse = `-- name: CreateCourse :one

INSERT INTO course (
    uuid, name, description, created_at, updated_at
) VALUES (
    ?, ?, ?, ?, ?
) RETURNING uuid, name, description, created_at, updated_at, archived, state
`

type CreateCourseParams struct {
	Uuid        string `json:"uuid"`
	Name        string `json:"name"`
	Description string `json:"description"`
	CreatedAt   int64  `json:"created_at"`
	UpdatedAt   int64  `json:"updated_at"`
}

// * Course
func (q *Queries) CreateCourse(ctx context.Context, arg CreateCourseParams) (Course, error) {
	row := q.db.QueryRowContext(ctx, createCourse,
		arg.Uuid,
		arg.Name,
		arg.Description,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Course
	err := row.Scan(
		&i.Uuid,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Archived,
		&i.State,
	)
	return i, err
}

const createHeading = `-- name: CreateHeading :one

INSERT INTO heading (
    uuid, content, created_at, updated_at
) VALUES (
    ?, ?, ?, ?
) RETURNING uuid, course_uuid, content, created_at, updated_at
`

type CreateHeadingParams struct {
	Uuid      string `json:"uuid"`
	Content   string `json:"content"`
	CreatedAt int64  `json:"created_at"`
	UpdatedAt int64  `json:"updated_at"`
}

// * Heading
func (q *Queries) CreateHeading(ctx context.Context, arg CreateHeadingParams) (Heading, error) {
	row := q.db.QueryRowContext(ctx, createHeading,
		arg.Uuid,
		arg.Content,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Heading
	err := row.Scan(
		&i.Uuid,
		&i.CourseUuid,
		&i.Content,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createMaterial = `-- name: CreateMaterial :one

INSERT INTO material (
    uuid, course_uuid, name, description, url, type, favicon_url, byte_size, mime_type, created_at, updated_at
) VALUES (
    ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
) RETURNING uuid, course_uuid, name, description, url, type, favicon_url, mime_type, byte_size, created_at, updated_at
`

type CreateMaterialParams struct {
	Uuid        string         `json:"uuid"`
	CourseUuid  string         `json:"course_uuid"`
	Name        string         `json:"name"`
	Description string         `json:"description"`
	Url         string         `json:"url"`
	Type        string         `json:"type"`
	FaviconUrl  sql.NullString `json:"favicon_url"`
	ByteSize    sql.NullInt64  `json:"byte_size"`
	MimeType    sql.NullString `json:"mime_type"`
	CreatedAt   int64          `json:"created_at"`
	UpdatedAt   int64          `json:"updated_at"`
}

// * Material
func (q *Queries) CreateMaterial(ctx context.Context, arg CreateMaterialParams) (Material, error) {
	row := q.db.QueryRowContext(ctx, createMaterial,
		arg.Uuid,
		arg.CourseUuid,
		arg.Name,
		arg.Description,
		arg.Url,
		arg.Type,
		arg.FaviconUrl,
		arg.ByteSize,
		arg.MimeType,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Material
	err := row.Scan(
		&i.Uuid,
		&i.CourseUuid,
		&i.Name,
		&i.Description,
		&i.Url,
		&i.Type,
		&i.FaviconUrl,
		&i.MimeType,
		&i.ByteSize,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createModule = `-- name: CreateModule :one

INSERT INTO module (
    uuid, course_uuid, name, description, created_at, updated_at
) VALUES (
    ?, ?, ?, ?, ?, ?
) RETURNING uuid, course_uuid, name, description, state, created_at, updated_at
`

type CreateModuleParams struct {
	Uuid        string `json:"uuid"`
	CourseUuid  string `json:"course_uuid"`
	Name        string `json:"name"`
	Description string `json:"description"`
	CreatedAt   int64  `json:"created_at"`
	UpdatedAt   int64  `json:"updated_at"`
}

// * Module
func (q *Queries) CreateModule(ctx context.Context, arg CreateModuleParams) (Module, error) {
	row := q.db.QueryRowContext(ctx, createModule,
		arg.Uuid,
		arg.CourseUuid,
		arg.Name,
		arg.Description,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Module
	err := row.Scan(
		&i.Uuid,
		&i.CourseUuid,
		&i.Name,
		&i.Description,
		&i.State,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createPost = `-- name: CreatePost :one
INSERT INTO feed_posts (uuid, course_uuid, type, message, is_edited, created_at, updated_at)
VALUES (?, ?, ?, ?, ?, ?, ?)
RETURNING uuid, course_uuid, type, message, is_edited, created_at, updated_at
`

type CreatePostParams struct {
	Uuid       string `json:"uuid"`
	CourseUuid string `json:"course_uuid"`
	Type       string `json:"type"`
	Message    string `json:"message"`
	IsEdited   bool   `json:"is_edited"`
	CreatedAt  int64  `json:"created_at"`
	UpdatedAt  int64  `json:"updated_at"`
}

func (q *Queries) CreatePost(ctx context.Context, arg CreatePostParams) (FeedPost, error) {
	row := q.db.QueryRowContext(ctx, createPost,
		arg.Uuid,
		arg.CourseUuid,
		arg.Type,
		arg.Message,
		arg.IsEdited,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i FeedPost
	err := row.Scan(
		&i.Uuid,
		&i.CourseUuid,
		&i.Type,
		&i.Message,
		&i.IsEdited,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createQuestion = `-- name: CreateQuestion :one

INSERT INTO question (
    uuid, quiz_uuid, question_order, type, question_text, options, correct_indices
) SELECT 
    ?1,
    ?2,
    COALESCE(MAX("question_order"), 0) + 1,    
    ?3,
    ?4,
    ?5,
    ?6
FROM question
WHERE quiz_uuid = ?2
RETURNING uuid, quiz_uuid, question_order, type, question_text, options, correct_indices
`

type CreateQuestionParams struct {
	Uuid           string `json:"uuid"`
	QuizUuid       string `json:"quiz_uuid"`
	Type           string `json:"type"`
	QuestionText   string `json:"question_text"`
	Options        string `json:"options"`
	CorrectIndices string `json:"correct_indices"`
}

// * Question
func (q *Queries) CreateQuestion(ctx context.Context, arg CreateQuestionParams) (Question, error) {
	row := q.db.QueryRowContext(ctx, createQuestion,
		arg.Uuid,
		arg.QuizUuid,
		arg.Type,
		arg.QuestionText,
		arg.Options,
		arg.CorrectIndices,
	)
	var i Question
	err := row.Scan(
		&i.Uuid,
		&i.QuizUuid,
		&i.QuestionOrder,
		&i.Type,
		&i.QuestionText,
		&i.Options,
		&i.CorrectIndices,
	)
	return i, err
}

const createQuiz = `-- name: CreateQuiz :one

INSERT INTO quiz (
    uuid, course_uuid, title, attempts_count, created_at, updated_at
) VALUES (
    ?, ?, ?, ?, ?, ?
) RETURNING uuid, course_uuid, title, attempts_count, created_at, updated_at
`

type CreateQuizParams struct {
	Uuid          string `json:"uuid"`
	CourseUuid    string `json:"course_uuid"`
	Title         string `json:"title"`
	AttemptsCount int64  `json:"attempts_count"`
	CreatedAt     int64  `json:"created_at"`
	UpdatedAt     int64  `json:"updated_at"`
}

// * Quiz
func (q *Queries) CreateQuiz(ctx context.Context, arg CreateQuizParams) (Quiz, error) {
	row := q.db.QueryRowContext(ctx, createQuiz,
		arg.Uuid,
		arg.CourseUuid,
		arg.Title,
		arg.AttemptsCount,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Quiz
	err := row.Scan(
		&i.Uuid,
		&i.CourseUuid,
		&i.Title,
		&i.AttemptsCount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createSession = `-- name: CreateSession :one

INSERT INTO session (
    user_id, token, created_at, expires_at
) VALUES (
    ?, ?, ?, ?
) RETURNING id, user_id, token, created_at, expires_at
`

type CreateSessionParams struct {
	UserID    int64  `json:"user_id"`
	Token     string `json:"token"`
	CreatedAt int64  `json:"created_at"`
	ExpiresAt int64  `json:"expires_at"`
}

// * Session
func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) (Session, error) {
	row := q.db.QueryRowContext(ctx, createSession,
		arg.UserID,
		arg.Token,
		arg.CreatedAt,
		arg.ExpiresAt,
	)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Token,
		&i.CreatedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO user (first_name, last_name, hash, email) VALUES (?, ?, ?, ?) RETURNING id, first_name, last_name, hash, email
`

type CreateUserParams struct {
	FirstName string `json:"first_name"`
	LastName  string `json:"last_name"`
	Hash      string `json:"hash"`
	Email     string `json:"email"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.FirstName,
		arg.LastName,
		arg.Hash,
		arg.Email,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Hash,
		&i.Email,
	)
	return i, err
}

const deleteCourse = `-- name: DeleteCourse :execresult
DELETE FROM course WHERE course.uuid = ?
`

func (q *Queries) DeleteCourse(ctx context.Context, uuid string) (sql.Result, error) {
	return q.db.ExecContext(ctx, deleteCourse, uuid)
}

const deleteHeading = `-- name: DeleteHeading :exec
DELETE FROM heading WHERE uuid = ?
`

func (q *Queries) DeleteHeading(ctx context.Context, uuid string) error {
	_, err := q.db.ExecContext(ctx, deleteHeading, uuid)
	return err
}

const deleteMaterial = `-- name: DeleteMaterial :execresult
DELETE FROM material WHERE material.uuid = ?
`

func (q *Queries) DeleteMaterial(ctx context.Context, uuid string) (sql.Result, error) {
	return q.db.ExecContext(ctx, deleteMaterial, uuid)
}

const deletePost = `-- name: DeletePost :exec
DELETE FROM feed_posts
WHERE uuid = ?
`

func (q *Queries) DeletePost(ctx context.Context, uuid string) error {
	_, err := q.db.ExecContext(ctx, deletePost, uuid)
	return err
}

const deleteQuestionsOfQuiz = `-- name: DeleteQuestionsOfQuiz :execresult
DELETE FROM question WHERE quiz_uuid = ?
`

func (q *Queries) DeleteQuestionsOfQuiz(ctx context.Context, quizUuid string) (sql.Result, error) {
	return q.db.ExecContext(ctx, deleteQuestionsOfQuiz, quizUuid)
}

const deleteQuiz = `-- name: DeleteQuiz :execresult
DELETE FROM quiz WHERE uuid = ?
`

func (q *Queries) DeleteQuiz(ctx context.Context, uuid string) (sql.Result, error) {
	return q.db.ExecContext(ctx, deleteQuiz, uuid)
}

const getAnswersOfQuiz = `-- name: GetAnswersOfQuiz :many

SELECT quiz_uuid, comment, score, max_score, user_id, attempt_number, submitted_at, "foreign" FROM answer WHERE quiz_uuid = ? ORDER BY answer.submitted_at DESC
`

// TODO RETURN ANSWERS AND SHOW THEM ON FRONTEND
func (q *Queries) GetAnswersOfQuiz(ctx context.Context, quizUuid string) ([]Answer, error) {
	rows, err := q.db.QueryContext(ctx, getAnswersOfQuiz, quizUuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Answer
	for rows.Next() {
		var i Answer
		if err := rows.Scan(
			&i.QuizUuid,
			&i.Comment,
			&i.Score,
			&i.MaxScore,
			&i.UserID,
			&i.AttemptNumber,
			&i.SubmittedAt,
			&i.Foreign,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCourse = `-- name: GetCourse :one
SELECT uuid, name, description, created_at, updated_at, archived, state FROM course WHERE course.uuid == ?
`

func (q *Queries) GetCourse(ctx context.Context, uuid string) (Course, error) {
	row := q.db.QueryRowContext(ctx, getCourse, uuid)
	var i Course
	err := row.Scan(
		&i.Uuid,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Archived,
		&i.State,
	)
	return i, err
}

const getHeading = `-- name: GetHeading :one
SELECT uuid, course_uuid, content, created_at, updated_at FROM heading WHERE uuid = ?
`

func (q *Queries) GetHeading(ctx context.Context, uuid string) (Heading, error) {
	row := q.db.QueryRowContext(ctx, getHeading, uuid)
	var i Heading
	err := row.Scan(
		&i.Uuid,
		&i.CourseUuid,
		&i.Content,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMaterial = `-- name: GetMaterial :one
SELECT uuid, course_uuid, name, description, url, type, favicon_url, mime_type, byte_size, created_at, updated_at FROM material WHERE material.uuid = ?
`

func (q *Queries) GetMaterial(ctx context.Context, uuid string) (Material, error) {
	row := q.db.QueryRowContext(ctx, getMaterial, uuid)
	var i Material
	err := row.Scan(
		&i.Uuid,
		&i.CourseUuid,
		&i.Name,
		&i.Description,
		&i.Url,
		&i.Type,
		&i.FaviconUrl,
		&i.MimeType,
		&i.ByteSize,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getModule = `-- name: GetModule :one
SELECT uuid, course_uuid, name, description, state, created_at, updated_at FROM module WHERE uuid = ? AND course_uuid = ?
`

type GetModuleParams struct {
	Uuid       string `json:"uuid"`
	CourseUuid string `json:"course_uuid"`
}

func (q *Queries) GetModule(ctx context.Context, arg GetModuleParams) (Module, error) {
	row := q.db.QueryRowContext(ctx, getModule, arg.Uuid, arg.CourseUuid)
	var i Module
	err := row.Scan(
		&i.Uuid,
		&i.CourseUuid,
		&i.Name,
		&i.Description,
		&i.State,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getModuleContents = `-- name: GetModuleContents :many

SELECT 
    'material' AS item_type,
    m.uuid,
    m.name AS display_name,
    m.description,
    mtm."order"
FROM material_to_module mtm
JOIN material m ON mtm.material_uuid = m.uuid
WHERE mtm.module_uuid = ? AND m.course_uuid = ?

UNION ALL

SELECT 
    'quiz' AS item_type,
    q.uuid,
    q.title AS display_name,
    '' AS description,
    qtm."order"
FROM quiz_to_module qtm
JOIN quiz q ON qtm.quiz_uuid = q.uuid
WHERE qtm.module_uuid = ? AND q.course_uuid = ?

UNION ALL

SELECT 
    'heading' AS item_type,
    h.uuid,
    h.content AS display_name,
    '' AS description,
    htm."order"
FROM heading_to_module htm
JOIN heading h ON htm.heading_uuid = h.uuid
WHERE htm.module_uuid = ? AND h.course_uuid = ?

ORDER BY "order" ASC
`

type GetModuleContentsParams struct {
	ModuleUuid   string `json:"module_uuid"`
	CourseUuid   string `json:"course_uuid"`
	ModuleUuid_2 string `json:"module_uuid_2"`
	CourseUuid_2 string `json:"course_uuid_2"`
	ModuleUuid_3 string `json:"module_uuid_3"`
	CourseUuid_3 string `json:"course_uuid_3"`
}

type GetModuleContentsRow struct {
	ItemType    string `json:"item_type"`
	Uuid        string `json:"uuid"`
	DisplayName string `json:"display_name"`
	Description string `json:"description"`
	Order       int64  `json:"order"`
}

// * ModuleContents
func (q *Queries) GetModuleContents(ctx context.Context, arg GetModuleContentsParams) ([]GetModuleContentsRow, error) {
	rows, err := q.db.QueryContext(ctx, getModuleContents,
		arg.ModuleUuid,
		arg.CourseUuid,
		arg.ModuleUuid_2,
		arg.CourseUuid_2,
		arg.ModuleUuid_3,
		arg.CourseUuid_3,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetModuleContentsRow
	for rows.Next() {
		var i GetModuleContentsRow
		if err := rows.Scan(
			&i.ItemType,
			&i.Uuid,
			&i.DisplayName,
			&i.Description,
			&i.Order,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPost = `-- name: GetPost :one
SELECT uuid, course_uuid, type, message, is_edited, created_at, updated_at FROM feed_posts
WHERE uuid = ?
`

func (q *Queries) GetPost(ctx context.Context, uuid string) (FeedPost, error) {
	row := q.db.QueryRowContext(ctx, getPost, uuid)
	var i FeedPost
	err := row.Scan(
		&i.Uuid,
		&i.CourseUuid,
		&i.Type,
		&i.Message,
		&i.IsEdited,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPostsByCourse = `-- name: GetPostsByCourse :many

SELECT uuid, course_uuid, type, message, is_edited, created_at, updated_at FROM feed_posts
WHERE course_uuid = ?
ORDER BY created_at DESC
`

// * Posts
func (q *Queries) GetPostsByCourse(ctx context.Context, courseUuid string) ([]FeedPost, error) {
	rows, err := q.db.QueryContext(ctx, getPostsByCourse, courseUuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FeedPost
	for rows.Next() {
		var i FeedPost
		if err := rows.Scan(
			&i.Uuid,
			&i.CourseUuid,
			&i.Type,
			&i.Message,
			&i.IsEdited,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getQuestionsOfQuiz = `-- name: GetQuestionsOfQuiz :many
SELECT uuid, quiz_uuid, question_order, type, question_text, options, correct_indices FROM question WHERE quiz_uuid = ?
`

func (q *Queries) GetQuestionsOfQuiz(ctx context.Context, quizUuid string) ([]Question, error) {
	rows, err := q.db.QueryContext(ctx, getQuestionsOfQuiz, quizUuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Question
	for rows.Next() {
		var i Question
		if err := rows.Scan(
			&i.Uuid,
			&i.QuizUuid,
			&i.QuestionOrder,
			&i.Type,
			&i.QuestionText,
			&i.Options,
			&i.CorrectIndices,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getQuiz = `-- name: GetQuiz :many
SELECT
    qz.uuid AS quiz_uuid,
    qz.course_uuid AS course_uuid,

    qz.title AS quiz_title,
    qz.attempts_count AS quiz_attempts_count,
    qz.created_at AS quiz_created_at,
    qz.updated_at AS quiz_updated_at,

    qs.uuid AS question_uuid,
    qs.question_order AS question_order,
    qs.type AS question_type,
    qs.question_text AS question_text,
    qs.options AS question_options,
    qs.correct_indices AS question_correct_indices
FROM quiz qz
LEFT JOIN question qs
    ON qs.quiz_uuid = qz.uuid
WHERE qz.uuid = ?
ORDER BY qs.question_order
`

type GetQuizRow struct {
	QuizUuid               string         `json:"quiz_uuid"`
	CourseUuid             string         `json:"course_uuid"`
	QuizTitle              string         `json:"quiz_title"`
	QuizAttemptsCount      int64          `json:"quiz_attempts_count"`
	QuizCreatedAt          int64          `json:"quiz_created_at"`
	QuizUpdatedAt          int64          `json:"quiz_updated_at"`
	QuestionUuid           sql.NullString `json:"question_uuid"`
	QuestionOrder          sql.NullInt64  `json:"question_order"`
	QuestionType           sql.NullString `json:"question_type"`
	QuestionText           sql.NullString `json:"question_text"`
	QuestionOptions        sql.NullString `json:"question_options"`
	QuestionCorrectIndices sql.NullString `json:"question_correct_indices"`
}

func (q *Queries) GetQuiz(ctx context.Context, uuid string) ([]GetQuizRow, error) {
	rows, err := q.db.QueryContext(ctx, getQuiz, uuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetQuizRow
	for rows.Next() {
		var i GetQuizRow
		if err := rows.Scan(
			&i.QuizUuid,
			&i.CourseUuid,
			&i.QuizTitle,
			&i.QuizAttemptsCount,
			&i.QuizCreatedAt,
			&i.QuizUpdatedAt,
			&i.QuestionUuid,
			&i.QuestionOrder,
			&i.QuestionType,
			&i.QuestionText,
			&i.QuestionOptions,
			&i.QuestionCorrectIndices,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUser = `-- name: GetUser :one

SELECT id, first_name, last_name, hash, email FROM user WHERE user.id = ?
`

// * USER
func (q *Queries) GetUser(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRowContext(ctx, getUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Hash,
		&i.Email,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, first_name, last_name, hash, email FROM user WHERE user.email = ?
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Hash,
		&i.Email,
	)
	return i, err
}

const getUserBySessionToken = `-- name: GetUserBySessionToken :one
SELECT user.id, first_name, last_name, hash, email, session.id, user_id, token, created_at, expires_at FROM user
JOIN session on user.id = session.user_id
WHERE session.token = ?
`

type GetUserBySessionTokenRow struct {
	ID        int64  `json:"id"`
	FirstName string `json:"first_name"`
	LastName  string `json:"last_name"`
	Hash      string `json:"hash"`
	Email     string `json:"email"`
	ID_2      int64  `json:"id_2"`
	UserID    int64  `json:"user_id"`
	Token     string `json:"token"`
	CreatedAt int64  `json:"created_at"`
	ExpiresAt int64  `json:"expires_at"`
}

func (q *Queries) GetUserBySessionToken(ctx context.Context, token string) (GetUserBySessionTokenRow, error) {
	row := q.db.QueryRowContext(ctx, getUserBySessionToken, token)
	var i GetUserBySessionTokenRow
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Hash,
		&i.Email,
		&i.ID_2,
		&i.UserID,
		&i.Token,
		&i.CreatedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const incrementQuizAttemptsCount = `-- name: IncrementQuizAttemptsCount :exec
UPDATE quiz
SET
    attempts_count = attempts_count + 1
WHERE uuid = ?
`

func (q *Queries) IncrementQuizAttemptsCount(ctx context.Context, uuid string) error {
	_, err := q.db.ExecContext(ctx, incrementQuizAttemptsCount, uuid)
	return err
}

const insertAnswer = `-- name: InsertAnswer :one

INSERT INTO answer (
    quiz_uuid, comment, score, max_score, user_id, attempt_number, submitted_at
) VALUES (
    ?1,
    ?2,
    
    ?3,
    ?4,

    ?5,
    CASE
        WHEN ?5 IS NULL THEN 0
        ELSE (
            SELECT COALESCE(MAX(answer.attempt_number), 0) + 1
            FROM answer
                WHERE answer.quiz_uuid = ?1 
                    AND answer.user_id = ?5
        )
    END,
    ?6
) RETURNING quiz_uuid, comment, score, max_score, user_id, attempt_number, submitted_at, "foreign"
`

type InsertAnswerParams struct {
	QuizUuid    string         `json:"quiz_uuid"`
	Comment     sql.NullString `json:"comment"`
	Score       int64          `json:"score"`
	MaxScore    int64          `json:"max_score"`
	UserID      sql.NullInt64  `json:"user_id"`
	SubmittedAt int64          `json:"submitted_at"`
}

// * Answers
func (q *Queries) InsertAnswer(ctx context.Context, arg InsertAnswerParams) (Answer, error) {
	row := q.db.QueryRowContext(ctx, insertAnswer,
		arg.QuizUuid,
		arg.Comment,
		arg.Score,
		arg.MaxScore,
		arg.UserID,
		arg.SubmittedAt,
	)
	var i Answer
	err := row.Scan(
		&i.QuizUuid,
		&i.Comment,
		&i.Score,
		&i.MaxScore,
		&i.UserID,
		&i.AttemptNumber,
		&i.SubmittedAt,
		&i.Foreign,
	)
	return i, err
}

const invalidateSession = `-- name: InvalidateSession :exec
DELETE FROM session WHERE token = ?
`

func (q *Queries) InvalidateSession(ctx context.Context, token string) error {
	_, err := q.db.ExecContext(ctx, invalidateSession, token)
	return err
}

const listAllCourses = `-- name: ListAllCourses :many
SELECT uuid, name, description, created_at, updated_at, archived, state FROM course
`

func (q *Queries) ListAllCourses(ctx context.Context) ([]Course, error) {
	rows, err := q.db.QueryContext(ctx, listAllCourses)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Course
	for rows.Next() {
		var i Course
		if err := rows.Scan(
			&i.Uuid,
			&i.Name,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Archived,
			&i.State,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllMaterialsOfCourse = `-- name: ListAllMaterialsOfCourse :many
SELECT uuid, course_uuid, name, description, url, type, favicon_url, mime_type, byte_size, created_at, updated_at FROM material WHERE material.course_uuid = ? ORDER BY created_at DESC
`

func (q *Queries) ListAllMaterialsOfCourse(ctx context.Context, courseUuid string) ([]Material, error) {
	rows, err := q.db.QueryContext(ctx, listAllMaterialsOfCourse, courseUuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Material
	for rows.Next() {
		var i Material
		if err := rows.Scan(
			&i.Uuid,
			&i.CourseUuid,
			&i.Name,
			&i.Description,
			&i.Url,
			&i.Type,
			&i.FaviconUrl,
			&i.MimeType,
			&i.ByteSize,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQuizes = `-- name: ListQuizes :many
SELECT
    qz.uuid AS quiz_uuid,
    qz.course_uuid AS course_uuid,

    qz.title AS quiz_title,
    qz.attempts_count AS quiz_attempts_count,
    qz.created_at AS quiz_created_at,
    qz.updated_at AS quiz_updated_at,

    qs.uuid AS question_uuid,
    qs.question_order AS question_order,
    qs.type AS question_type,
    qs.question_text AS question_text,
    qs.options AS question_options,
    qs.correct_indices AS question_correct_indices
FROM quiz qz
LEFT JOIN question qs
    ON qs.quiz_uuid = qz.uuid
WHERE qz.course_uuid = ?
ORDER BY qz.uuid ASC, qs.question_order ASC
`

type ListQuizesRow struct {
	QuizUuid               string         `json:"quiz_uuid"`
	CourseUuid             string         `json:"course_uuid"`
	QuizTitle              string         `json:"quiz_title"`
	QuizAttemptsCount      int64          `json:"quiz_attempts_count"`
	QuizCreatedAt          int64          `json:"quiz_created_at"`
	QuizUpdatedAt          int64          `json:"quiz_updated_at"`
	QuestionUuid           sql.NullString `json:"question_uuid"`
	QuestionOrder          sql.NullInt64  `json:"question_order"`
	QuestionType           sql.NullString `json:"question_type"`
	QuestionText           sql.NullString `json:"question_text"`
	QuestionOptions        sql.NullString `json:"question_options"`
	QuestionCorrectIndices sql.NullString `json:"question_correct_indices"`
}

func (q *Queries) ListQuizes(ctx context.Context, courseUuid string) ([]ListQuizesRow, error) {
	rows, err := q.db.QueryContext(ctx, listQuizes, courseUuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListQuizesRow
	for rows.Next() {
		var i ListQuizesRow
		if err := rows.Scan(
			&i.QuizUuid,
			&i.CourseUuid,
			&i.QuizTitle,
			&i.QuizAttemptsCount,
			&i.QuizCreatedAt,
			&i.QuizUpdatedAt,
			&i.QuestionUuid,
			&i.QuestionOrder,
			&i.QuestionType,
			&i.QuestionText,
			&i.QuestionOptions,
			&i.QuestionCorrectIndices,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const makeUserAdmin = `-- name: MakeUserAdmin :exec

INSERT INTO admin (user_id) VALUES (?)
`

// * Admin
func (q *Queries) MakeUserAdmin(ctx context.Context, userID int64) error {
	_, err := q.db.ExecContext(ctx, makeUserAdmin, userID)
	return err
}

const removeHeadingFromModule = `-- name: RemoveHeadingFromModule :exec
DELETE FROM heading_to_module WHERE heading_uuid = ? AND module_uuid = ?
`

type RemoveHeadingFromModuleParams struct {
	HeadingUuid string `json:"heading_uuid"`
	ModuleUuid  string `json:"module_uuid"`
}

func (q *Queries) RemoveHeadingFromModule(ctx context.Context, arg RemoveHeadingFromModuleParams) error {
	_, err := q.db.ExecContext(ctx, removeHeadingFromModule, arg.HeadingUuid, arg.ModuleUuid)
	return err
}

const removeMaterialFromModule = `-- name: RemoveMaterialFromModule :exec
DELETE FROM material_to_module WHERE material_uuid = ? AND module_uuid = ?
`

type RemoveMaterialFromModuleParams struct {
	MaterialUuid string `json:"material_uuid"`
	ModuleUuid   string `json:"module_uuid"`
}

func (q *Queries) RemoveMaterialFromModule(ctx context.Context, arg RemoveMaterialFromModuleParams) error {
	_, err := q.db.ExecContext(ctx, removeMaterialFromModule, arg.MaterialUuid, arg.ModuleUuid)
	return err
}

const removeQuizFromModule = `-- name: RemoveQuizFromModule :exec
DELETE FROM quiz_to_module WHERE quiz_uuid = ? AND module_uuid = ?
`

type RemoveQuizFromModuleParams struct {
	QuizUuid   string `json:"quiz_uuid"`
	ModuleUuid string `json:"module_uuid"`
}

func (q *Queries) RemoveQuizFromModule(ctx context.Context, arg RemoveQuizFromModuleParams) error {
	_, err := q.db.ExecContext(ctx, removeQuizFromModule, arg.QuizUuid, arg.ModuleUuid)
	return err
}

const updateCourse = `-- name: UpdateCourse :one
UPDATE course SET name = ?, description = ?, updated_at = ? WHERE course.uuid = ? RETURNING uuid, name, description, created_at, updated_at, archived, state
`

type UpdateCourseParams struct {
	Name        string `json:"name"`
	Description string `json:"description"`
	UpdatedAt   int64  `json:"updated_at"`
	Uuid        string `json:"uuid"`
}

func (q *Queries) UpdateCourse(ctx context.Context, arg UpdateCourseParams) (Course, error) {
	row := q.db.QueryRowContext(ctx, updateCourse,
		arg.Name,
		arg.Description,
		arg.UpdatedAt,
		arg.Uuid,
	)
	var i Course
	err := row.Scan(
		&i.Uuid,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Archived,
		&i.State,
	)
	return i, err
}

const updateHeading = `-- name: UpdateHeading :one
UPDATE heading
SET
    content = ?,
    updated_at = ?
WHERE uuid = ?
RETURNING uuid, course_uuid, content, created_at, updated_at
`

type UpdateHeadingParams struct {
	Content   string `json:"content"`
	UpdatedAt int64  `json:"updated_at"`
	Uuid      string `json:"uuid"`
}

func (q *Queries) UpdateHeading(ctx context.Context, arg UpdateHeadingParams) (Heading, error) {
	row := q.db.QueryRowContext(ctx, updateHeading, arg.Content, arg.UpdatedAt, arg.Uuid)
	var i Heading
	err := row.Scan(
		&i.Uuid,
		&i.CourseUuid,
		&i.Content,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateMaterial = `-- name: UpdateMaterial :one
UPDATE material
SET 
    name = ?,
    description = ?,
    url = ?
WHERE material.uuid = ? RETURNING uuid, course_uuid, name, description, url, type, favicon_url, mime_type, byte_size, created_at, updated_at
`

type UpdateMaterialParams struct {
	Name        string `json:"name"`
	Description string `json:"description"`
	Url         string `json:"url"`
	Uuid        string `json:"uuid"`
}

func (q *Queries) UpdateMaterial(ctx context.Context, arg UpdateMaterialParams) (Material, error) {
	row := q.db.QueryRowContext(ctx, updateMaterial,
		arg.Name,
		arg.Description,
		arg.Url,
		arg.Uuid,
	)
	var i Material
	err := row.Scan(
		&i.Uuid,
		&i.CourseUuid,
		&i.Name,
		&i.Description,
		&i.Url,
		&i.Type,
		&i.FaviconUrl,
		&i.MimeType,
		&i.ByteSize,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateMaterialPartial = `-- name: UpdateMaterialPartial :one
UPDATE material
SET
    name        = COALESCE(?1, name),
    description = COALESCE(?2, description),
    url         = COALESCE(?3, url),
    favicon_url = COALESCE(?4, favicon_url),
    byte_size   = COALESCE(?5, byte_size),
    mime_type   = COALESCE(?6, mime_type),
    updated_at  = ?7
WHERE uuid = ?8 RETURNING uuid, course_uuid, name, description, url, type, favicon_url, mime_type, byte_size, created_at, updated_at
`

type UpdateMaterialPartialParams struct {
	Name        sql.NullString `json:"name"`
	Description sql.NullString `json:"description"`
	Url         sql.NullString `json:"url"`
	FaviconUrl  sql.NullString `json:"favicon_url"`
	ByteSize    sql.NullInt64  `json:"byte_size"`
	MimeType    sql.NullString `json:"mime_type"`
	UpdatedAt   int64          `json:"updated_at"`
	Uuid        string         `json:"uuid"`
}

func (q *Queries) UpdateMaterialPartial(ctx context.Context, arg UpdateMaterialPartialParams) (Material, error) {
	row := q.db.QueryRowContext(ctx, updateMaterialPartial,
		arg.Name,
		arg.Description,
		arg.Url,
		arg.FaviconUrl,
		arg.ByteSize,
		arg.MimeType,
		arg.UpdatedAt,
		arg.Uuid,
	)
	var i Material
	err := row.Scan(
		&i.Uuid,
		&i.CourseUuid,
		&i.Name,
		&i.Description,
		&i.Url,
		&i.Type,
		&i.FaviconUrl,
		&i.MimeType,
		&i.ByteSize,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateModule = `-- name: UpdateModule :one
UPDATE module
SET
    name = ?,
    description = ?
WHERE
    uuid = ? and course_uuid = ?
RETURNING uuid, course_uuid, name, description, state, created_at, updated_at
`

type UpdateModuleParams struct {
	Name        string `json:"name"`
	Description string `json:"description"`
	Uuid        string `json:"uuid"`
	CourseUuid  string `json:"course_uuid"`
}

func (q *Queries) UpdateModule(ctx context.Context, arg UpdateModuleParams) (Module, error) {
	row := q.db.QueryRowContext(ctx, updateModule,
		arg.Name,
		arg.Description,
		arg.Uuid,
		arg.CourseUuid,
	)
	var i Module
	err := row.Scan(
		&i.Uuid,
		&i.CourseUuid,
		&i.Name,
		&i.Description,
		&i.State,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updatePost = `-- name: UpdatePost :one
UPDATE feed_posts
SET message = ?, is_edited = 1, updated_at = ?
WHERE uuid = ?
RETURNING uuid, course_uuid, type, message, is_edited, created_at, updated_at
`

type UpdatePostParams struct {
	Message   string `json:"message"`
	UpdatedAt int64  `json:"updated_at"`
	Uuid      string `json:"uuid"`
}

func (q *Queries) UpdatePost(ctx context.Context, arg UpdatePostParams) (FeedPost, error) {
	row := q.db.QueryRowContext(ctx, updatePost, arg.Message, arg.UpdatedAt, arg.Uuid)
	var i FeedPost
	err := row.Scan(
		&i.Uuid,
		&i.CourseUuid,
		&i.Type,
		&i.Message,
		&i.IsEdited,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateQuestion = `-- name: UpdateQuestion :one
UPDATE question
SET
    question_text = COALESCE(?1, question_text),
    options = COALESCE(?2, options),
    correct_indices = COALESCE(?3, correct_indices)
RETURNING uuid, quiz_uuid, question_order, type, question_text, options, correct_indices
`

type UpdateQuestionParams struct {
	QuestionText   sql.NullString `json:"question_text"`
	Options        sql.NullString `json:"options"`
	CorrectIndices sql.NullString `json:"correct_indices"`
}

func (q *Queries) UpdateQuestion(ctx context.Context, arg UpdateQuestionParams) (Question, error) {
	row := q.db.QueryRowContext(ctx, updateQuestion, arg.QuestionText, arg.Options, arg.CorrectIndices)
	var i Question
	err := row.Scan(
		&i.Uuid,
		&i.QuizUuid,
		&i.QuestionOrder,
		&i.Type,
		&i.QuestionText,
		&i.Options,
		&i.CorrectIndices,
	)
	return i, err
}

const updateQuiz = `-- name: UpdateQuiz :one
UPDATE quiz
SET
    title =             COALESCE(?1, title),
    attempts_count =    COALESCE(?2, attempts_count),
    updated_at =        COALESCE(?3, updated_at)
WHERE uuid = ?4
RETURNING uuid, course_uuid, title, attempts_count, created_at, updated_at
`

type UpdateQuizParams struct {
	Title         sql.NullString `json:"title"`
	AttemptsCount sql.NullInt64  `json:"attempts_count"`
	UpdatedAt     sql.NullInt64  `json:"updated_at"`
	Uuid          string         `json:"uuid"`
}

func (q *Queries) UpdateQuiz(ctx context.Context, arg UpdateQuizParams) (Quiz, error) {
	row := q.db.QueryRowContext(ctx, updateQuiz,
		arg.Title,
		arg.AttemptsCount,
		arg.UpdatedAt,
		arg.Uuid,
	)
	var i Quiz
	err := row.Scan(
		&i.Uuid,
		&i.CourseUuid,
		&i.Title,
		&i.AttemptsCount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
